// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AWSCompute struct {
	InstancePrice float64        `json:"instancePrice"`
	Instances     []*AWSInstance `json:"instances"`
}

type AWSDataTransfer struct {
	PricePerGb float64 `json:"pricePerGB"`
	Inbound    float64 `json:"inbound"`
	Outbound   float64 `json:"outbound"`
}

type AWSInstance struct {
	Type         string  `json:"type"`
	Vcpu         int     `json:"vcpu"`
	MemoryGb     float64 `json:"memoryGB"`
	PricePerHour float64 `json:"pricePerHour"`
	Architecture *string `json:"architecture,omitempty"`
	Burstable    *bool   `json:"burstable,omitempty"`
}

type AWSProvider struct {
	Compute      *AWSCompute      `json:"compute"`
	Storage      *AWSStorage      `json:"storage"`
	DataTransfer *AWSDataTransfer `json:"dataTransfer"`
}

type AWSStorage struct {
	PricePerGb float64           `json:"pricePerGB"`
	Tiers      []*AWSStorageTier `json:"tiers"`
}

type AWSStorageTier struct {
	Name        string  `json:"name"`
	PricePerGb  float64 `json:"pricePerGB"`
	Description *string `json:"description,omitempty"`
}

type AzureCompute struct {
	VMPrice float64    `json:"vmPrice"`
	Vms     []*AzureVM `json:"vms"`
}

type AzureDataTransfer struct {
	PricePerGb float64 `json:"pricePerGB"`
	Inbound    float64 `json:"inbound"`
	Outbound   float64 `json:"outbound"`
}

type AzureProvider struct {
	Compute      *AzureCompute      `json:"compute"`
	Storage      *AzureStorage      `json:"storage"`
	DataTransfer *AzureDataTransfer `json:"dataTransfer"`
}

type AzureStorage struct {
	PricePerGb float64             `json:"pricePerGB"`
	Tiers      []*AzureStorageTier `json:"tiers"`
}

type AzureStorageTier struct {
	Name        string  `json:"name"`
	PricePerGb  float64 `json:"pricePerGB"`
	Description *string `json:"description,omitempty"`
}

type AzureVM struct {
	Size         string  `json:"size"`
	Vcpu         int     `json:"vcpu"`
	MemoryGb     float64 `json:"memoryGB"`
	PricePerHour float64 `json:"pricePerHour"`
	Architecture *string `json:"architecture,omitempty"`
	Burstable    *bool   `json:"burstable,omitempty"`
}

type Category struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	CreatedAt   string  `json:"createdAt"`
}

type ETLJob struct {
	ID            string               `json:"id"`
	Type          ETLJobType           `json:"type"`
	Provider      *string              `json:"provider,omitempty"`
	Status        ETLJobStatus         `json:"status"`
	Progress      *ETLJobProgress      `json:"progress,omitempty"`
	StartedAt     string               `json:"startedAt"`
	CompletedAt   *string              `json:"completedAt,omitempty"`
	Error         *string              `json:"error,omitempty"`
	Configuration *ETLJobConfiguration `json:"configuration"`
}

type ETLJobConfiguration struct {
	Providers         []string `json:"providers,omitempty"`
	Regions           []string `json:"regions,omitempty"`
	Services          []string `json:"services,omitempty"`
	BatchSize         int      `json:"batchSize"`
	ConcurrentWorkers int      `json:"concurrentWorkers"`
	ClearExisting     bool     `json:"clearExisting"`
	DryRun            bool     `json:"dryRun"`
}

type ETLJobProgress struct {
	TotalRecords      int     `json:"totalRecords"`
	ProcessedRecords  int     `json:"processedRecords"`
	NormalizedRecords int     `json:"normalizedRecords"`
	SkippedRecords    int     `json:"skippedRecords"`
	ErrorRecords      int     `json:"errorRecords"`
	CurrentStage      string  `json:"currentStage"`
	LastUpdated       string  `json:"lastUpdated"`
	Rate              float64 `json:"rate"`
}

type Message struct {
	ID        string `json:"id"`
	Content   string `json:"content"`
	CreatedAt string `json:"createdAt"`
}

type Mutation struct {
}

type NormalizationConfigInput struct {
	Type              ETLJobType `json:"type"`
	Providers         []string   `json:"providers,omitempty"`
	Regions           []string   `json:"regions,omitempty"`
	Services          []string   `json:"services,omitempty"`
	BatchSize         *int       `json:"batchSize,omitempty"`
	ConcurrentWorkers *int       `json:"concurrentWorkers,omitempty"`
	ClearExisting     *bool      `json:"clearExisting,omitempty"`
	DryRun            *bool      `json:"dryRun,omitempty"`
}

type Provider struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	CreatedAt string `json:"createdAt"`
}

type Query struct {
}

type RegionComparison struct {
	Provider       string   `json:"provider"`
	Region         string   `json:"region"`
	RegionName     string   `json:"regionName"`
	MonthlyCost    float64  `json:"monthlyCost"`
	ComputeCost    float64  `json:"computeCost"`
	StorageCost    float64  `json:"storageCost"`
	EgressCost     float64  `json:"egressCost"`
	SavingsPercent float64  `json:"savingsPercent"`
	BestFor        []string `json:"bestFor"`
}

type RegionInput struct {
	Provider string `json:"provider"`
	Region   string `json:"region"`
}

type RegionOptimization struct {
	Provider        string   `json:"provider"`
	Region          string   `json:"region"`
	RegionName      string   `json:"regionName"`
	MonthlyCost     float64  `json:"monthlyCost"`
	ComputeCost     float64  `json:"computeCost"`
	StorageCost     float64  `json:"storageCost"`
	EgressCost      float64  `json:"egressCost"`
	Recommendations []string `json:"recommendations"`
}

type WorkloadInput struct {
	ComputeHours float64  `json:"computeHours"`
	StorageGb    float64  `json:"storageGB"`
	EgressGb     float64  `json:"egressGB"`
	CPUCount     *int     `json:"cpuCount,omitempty"`
	GpuCount     *int     `json:"gpuCount,omitempty"`
	Providers    []string `json:"providers,omitempty"`
	Geography    *string  `json:"geography,omitempty"`
}

type ETLJobStatus string

const (
	ETLJobStatusPending   ETLJobStatus = "PENDING"
	ETLJobStatusRunning   ETLJobStatus = "RUNNING"
	ETLJobStatusCompleted ETLJobStatus = "COMPLETED"
	ETLJobStatusFailed    ETLJobStatus = "FAILED"
	ETLJobStatusCancelled ETLJobStatus = "CANCELLED"
)

var AllETLJobStatus = []ETLJobStatus{
	ETLJobStatusPending,
	ETLJobStatusRunning,
	ETLJobStatusCompleted,
	ETLJobStatusFailed,
	ETLJobStatusCancelled,
}

func (e ETLJobStatus) IsValid() bool {
	switch e {
	case ETLJobStatusPending, ETLJobStatusRunning, ETLJobStatusCompleted, ETLJobStatusFailed, ETLJobStatusCancelled:
		return true
	}
	return false
}

func (e ETLJobStatus) String() string {
	return string(e)
}

func (e *ETLJobStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ETLJobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ETLJobStatus", str)
	}
	return nil
}

func (e ETLJobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ETLJobStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ETLJobStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ETLJobType string

const (
	ETLJobTypeNormalizeAll      ETLJobType = "NORMALIZE_ALL"
	ETLJobTypeNormalizeProvider ETLJobType = "NORMALIZE_PROVIDER"
	ETLJobTypeNormalizeRegion   ETLJobType = "NORMALIZE_REGION"
	ETLJobTypeNormalizeService  ETLJobType = "NORMALIZE_SERVICE"
	ETLJobTypeCleanupNormalized ETLJobType = "CLEANUP_NORMALIZED"
)

var AllETLJobType = []ETLJobType{
	ETLJobTypeNormalizeAll,
	ETLJobTypeNormalizeProvider,
	ETLJobTypeNormalizeRegion,
	ETLJobTypeNormalizeService,
	ETLJobTypeCleanupNormalized,
}

func (e ETLJobType) IsValid() bool {
	switch e {
	case ETLJobTypeNormalizeAll, ETLJobTypeNormalizeProvider, ETLJobTypeNormalizeRegion, ETLJobTypeNormalizeService, ETLJobTypeCleanupNormalized:
		return true
	}
	return false
}

func (e ETLJobType) String() string {
	return string(e)
}

func (e *ETLJobType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ETLJobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ETLJobType", str)
	}
	return nil
}

func (e ETLJobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ETLJobType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ETLJobType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
