type Query {
  hello: String!
  messages: [Message!]!
  providers: [Provider!]!
  categories: [Category!]!
  
  # Cloud Provider Pricing Queries
  aws: AWSProvider!
  azure: AzureProvider!
  
  # ETL Queries
  etlJob(id: ID!): ETLJob
  etlJobs: [ETLJob!]!
}

type Mutation {
  createMessage(content: String!): Message!
  
  # ETL Mutations
  startNormalization(config: NormalizationConfigInput!): ETLJob!
  cancelETLJob(id: ID!): Boolean!
}

type Message {
  id: ID!
  content: String!
  createdAt: String!
}

type Provider {
  id: ID!
  name: String!
  createdAt: String!
}

type Category {
  id: ID!
  name: String!
  description: String
  createdAt: String!
}

# ETL Types
type ETLJob {
  id: ID!
  type: ETLJobType!
  provider: String
  status: ETLJobStatus!
  progress: ETLJobProgress
  startedAt: String!
  completedAt: String
  error: String
  configuration: ETLJobConfiguration!
}

type ETLJobProgress {
  totalRecords: Int!
  processedRecords: Int!
  normalizedRecords: Int!
  skippedRecords: Int!
  errorRecords: Int!
  currentStage: String!
  lastUpdated: String!
  rate: Float!
}

type ETLJobConfiguration {
  providers: [String!]
  regions: [String!]
  services: [String!]
  batchSize: Int!
  concurrentWorkers: Int!
  clearExisting: Boolean!
  dryRun: Boolean!
}

enum ETLJobType {
  NORMALIZE_ALL
  NORMALIZE_PROVIDER
  NORMALIZE_REGION
  NORMALIZE_SERVICE
  CLEANUP_NORMALIZED
}

enum ETLJobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

input NormalizationConfigInput {
  type: ETLJobType!
  providers: [String!]
  regions: [String!]
  services: [String!]
  batchSize: Int
  concurrentWorkers: Int
  clearExisting: Boolean
  dryRun: Boolean
}

# AWS Provider Types
type AWSProvider {
  compute(region: String!): AWSCompute!
  storage(region: String!): AWSStorage!
  dataTransfer(region: String!): AWSDataTransfer!
}

type AWSCompute {
  instancePrice(type: String!): Float!
  instances: [AWSInstance!]!
}

type AWSInstance {
  type: String!
  vcpu: Int!
  memoryGB: Float!
  pricePerHour: Float!
  architecture: String
  burstable: Boolean
}

type AWSStorage {
  pricePerGB(tier: String!): Float!
  tiers: [AWSStorageTier!]!
}

type AWSStorageTier {
  name: String!
  pricePerGB: Float!
  description: String
}

type AWSDataTransfer {
  pricePerGB(direction: String!): Float!
  inbound: Float!
  outbound: Float!
}

# Azure Provider Types
type AzureProvider {
  compute(region: String!): AzureCompute!
  storage(region: String!): AzureStorage!
  dataTransfer(region: String!): AzureDataTransfer!
}

type AzureCompute {
  vmPrice(size: String!): Float!
  vms: [AzureVM!]!
}

type AzureVM {
  size: String!
  vcpu: Int!
  memoryGB: Float!
  pricePerHour: Float!
  architecture: String
  burstable: Boolean
}

type AzureStorage {
  pricePerGB(tier: String!): Float!
  tiers: [AzureStorageTier!]!
}

type AzureStorageTier {
  name: String!
  pricePerGB: Float!
  description: String
}

type AzureDataTransfer {
  pricePerGB(direction: String!): Float!
  inbound: Float!
  outbound: Float!
}